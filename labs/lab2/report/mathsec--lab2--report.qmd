---
## Author
author:
  name: Тазаева Анастасия Анатольевна
  degrees: BSc
  orcid: 
  email: 1032259385@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Лабораторная работа №2"
subtitle: "Шифры перестановки"
license: "CC BY"
---

# Цель работы

Ознакомиться с шифрами перестановки. Реализовать их.

# Задание

Реализовать на языке программирования Julia:

1. Маршрутное шифрование.
2. Шифрование с помощью решеток.
3. Таблица Виженера.

# Теоретическое введение

Шифры перестановки представляют собой метод криптографического преобразования, при котором символы исходного текста меняют свои позиции согласно определенному алгоритму. Ключом шифра служит способ перестановки букв. В данной лабораторной работе мы рассмотрим три шифра перестановки:

1. Маршрутное шифрование.
2. Шифрование с помощью решеток.
3. Таблица Виженера.

# Выполнение лабораторной работы

## Маршрутное шифрование

Написан программный код, реализующий маршрутное шифрование:

```Julia
function route_encrypt(text::String, code::String)
    ind = sortperm(split(code, ""))
    n = length(code)
    while mod(length(text), n) != 0
        text *= "z"
    end
    println("edited text: ", text)
    m = div(length(text), n) 
    println("matrix nxm: ", n, "x", m)
    x = split(text, "")
    x_matrix = reshape(x, n, m)
    x_matrix_res = copy(x_matrix)
    for i in 1:n
        x_matrix_res[i, :] = x_matrix[ind[i], :]
    end
    return result
end
```

Получен следующий результат выполнения программного кода ([рис. @fig-001]).

![Маршрутное шифрование. Примеры отработки](image/route.png){#fig-001 width=70%}

## Шифрование с помощью решеток

Написан программный код, реализующий шифрование с помощью решеток:

```Julia
using Random

function error_h(text)
    flag = false
    while !flag
        try 
            Int(sqrt(length(text))/2)
        catch
            text *= "a"
        else
            flag = true
        end
    end
    return Int(sqrt(length(text))/2), text
end

function grid_encrypt(text::String, code::String, slots::Vector)
    k, text = error_h(text) 
    if k<2 
        return println("k<2 error")
    end
    x = split(text, "") 
    if length(code) > 2*k 
        code = code[1:2*k] 
    elseif length(code) < 2*k  
        while length(code) < 2*k 
            code *= "a"
        end
    end
    if length(slots) != k^2 
        slots = rand(1:4, k^2) 
    end
    slots_q = Array{Integer, 2}(undef, 2*k, 2*k)
    slots_q[1:k, 1:k] = [slots[i+k*j] == 1 ? i+k*j : 0 for i=1:k, j=0:k-1]
    slots_q[1:k, k+1:2*k] = [slots[i+k*j] == 2 ? i+k*j : 0 for j=0:k-1,i=k:-1:1]
    slots_q[k+1:2*k, k+1:2*k] = [slots[i+k*j] == 3 ? i+k*j : 0 for j=k-1:-1:0, i=k:-1:1]
    slots_q[k+1:2*k, 1:k] = [slots[i+k*j] == 4 ? i+k*j : 0 for j=k-1:-1:0,i=1:k]
    text_m = Array{String, 2}(undef, 2*k, 2*k) 
    for i in 1:4
        for j in 1:k^2
            text_m[findfirst( x -> x== j, slots_q)] = x[(i-1)*k^2+j]
        end
        slots_q = rotr90(slots_q)
    end
    ind = sortperm(split(code, ""))
    res = copy(text_m)
    for i in 1:2*k
        res[i, :] = text_m[ind[i], :]
    end
    result=""
    for i in 1:2*k
        result *= join(res[i,:])
    end
    return result, code, slots
end
```

Получен следующий результат выполнения программного кода ([рис. @fig-002]).

![Шифрование с помощью решеток. Примеры отработки](image/grid.png){#fig-002 width=70%}

## Таблица Виженера

Написан программный код, реализующий шифрование с помощью таблицы Виженера:

```Julia
function vigenere_encrypt(text::String, key::String, mode::Symbol=:encrypt)
    alphabet = 'A':'Z'
    text = uppercase(text)
    key = uppercase(key)
    text = filter(c -> c in alphabet, text)
    result = []
    key_length = length(key)
    key_ind = 1
    shift = mode == :encrypt ? 1 : -1
    for char in text
        char_pos = findfirst(isequal(char), alphabet)
        key_char = key[key_ind]
        key_pos = findfirst(isequal(key_char),alphabet)
        new_pos = mod1(char_pos + shift * key_pos, length(alphabet))
        push!(result, alphabet[new_pos])
        key_ind = key_ind % key_length + 1
    end
    return join(result)
end
```

Получен следующий результат выполнения программного кода ([рис. @fig-003]).

![Шифрование с помощью таблицы Виженера. Примеры отработки](image/vigenere.png){#fig-003 width=70%}

# Выводы

В ходе лабораторной работы были изучены и реализованы шифры перестановки.

# Список литературы{.unnumbered}

::: {#refs}
:::
